---
layout: post
title:      "Procedural? Object-oriented? Try: Blocks."
date:       2018-03-20 18:31:01 +0000
permalink:  procedural_object-oriented_try_blocks
---

  I'ts MATH! It's RIDDLES! It's Super-Sized Coffee!
	
	Are you a new coder that knows procedural programming? Are you grey on object-oriented programming's usefulness? Let's talk. 
	
  The consensus online is that object-oriented programming is the way to go. After toying around in a few languages and seeing some of the standard enterprise setups: it likely still is. That said, even as a novice, one would quickly learn about a block of code. Blocks are used in both procedural and object-oriented coding. Let's think about something we hear about from childhood: building block learning.
	Most of us vaguely recall learning addition prior to multiplication, both of which were learned prior to algebra. That stepping stone, building-block, method is the same tool we use for almost all things. We use it for letters before sentence composition. We use it for astrophysics. It is difficult to imagine learning anything complicated via rote memorization or something NOT the building block method.
	So, how does this tie in? Well, from my pov: procedural programming (PP) is the block we master prior to object orientated programming (OOP). If anyone has dabbled in code, they learned what to type. They learned what a variable was. Then, they likely learned how to code some form of a block, such as a method or function.
	Without getting into gritty detail, let's recap in a loose manner what the two are. OOP relies on a design philosophy of code re-use, encompassing real-life objects/ideas into a tangible metaphor versions of code. Class Animal might have methods like #.eat or variables like #is_alive. One could take the structure of that Animal and begin applying it to some other project, say Class Dog. I will leave it at that, for brevity. Now, procedural programming takes a look at a problem, and breaks it down into smaller problems until its small enough to solve and you have something akin to a linkage of moving parts on a bicycle. Again, super simplifying. Another way to say it: define a list of things(procedure(s)) the program should do, and code them. 
  The last loose definition of PP I gave is of particular interest. One might read it and think, "Wouldn't that be the same in both philosophies?". Yea, basically. Just like if you're multiplying 4x10, one might say "Isn't it the same as just adding 4 + 4 + 4 [and so on]... = 10". Right? Right. The big difference that OOP minded people will offer is the flexibility to change the original code's variables around for a different purpose, without breaking the functionality of the code. If that doesn't make sense, then you're still learning OOP. 
	Either way, the big picture remains the same: PP's core design methodology is but a facet of OOP. One can not design an effective OBJECT without looking at the class and thinking about what it will do. Yes, there are many details one might consider, but I am purposefully being vague and shallow in their differences. Just like one might oversimplify how an aircraft propeller works by saying it does the same basic things as a screw being turned into a wall (trust me on that one).
	To summize, for new coders: don't stress over not learning OOP immediately. Whatever you learn, will help in the future, because coding is all about problem solving. Do learn OOP if you have not yet, but understand that it's just a natural next step and not some off the wall hipster fad. Regardless, New Coder, I hope you like math and riddles...or at least coffee ;)
	
	
